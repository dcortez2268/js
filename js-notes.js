// * JS can be run client-side(browser) with JS Engine, or can be run server-side in NODE, JS Engine embedded in c+ program

//***********************//
//RANDOM
//***********************//
// * Says it is best practice to put script element, at bottom of body rather than in head so browser can process Html without having to wait on JS, and also so the tags you may wish to display/hide are/aren't generated
// * strings enclosed in single or double quotes, doesnâ€™t matter, although JSON only allows double quotes
// * variables that have not been initialized are undefined type with value undefined
// * JS doesn't have different data type for floating points or integers, they are all Number type
// * JS Engine has automatic garbage collection

//************************************************* */
//  Data Types
//************************************************* */
//  PRIMITIVE/VALUE TYPES: String, Number, Boolean, undefined, null, Symbol(a unique identifier generated by Symbol() function)
//  REFERENCE TYPES: Objects, arrays, functions (arrays and functions are objects too)

// JS implements DYNAMIC TYPING:
//  variables type can be changed dynamically,
//  functions don't have to define return type,
//  method overloading can be done without defining multiple functions with diff signatures,
//  arrays can store objects of different types

//************************** */ 
//  NAMING CONVENTIONS:
//************************** */ 
//  variables: camelCase notation, case-sensitive
//  functions: camelCase notation
//  constructor functions: Pascal notation

//************************** */ 
// ### SCOPE OF VARIABLES:
//************************** */ 
//  BLOCK SCOPED VARIABLES: let and const variables, are only accessible inside current block and blocks within this block,
//  FUNCTION SCOPED VARIABLES: var variables, are accessible to blocks within this block, AND anywhere within function, attaches variables to Window object if outside function

//************************** */ 
this // keyword references the object that is executing the current function
//************************** */ 
// * if current function is function inside object, or constructor function, THIS references current object the method belongs to,
// * IF current function is regular standalone function (outside class, or callback inside a function inside class, or prototype method) THIS references global object (in browser window, in node global), important to remember

// * apply(), bind(), call(): can change value of this for functions
// * apply and call: call the method and supply object in argument to reference as this,
// * bind: does not call the method, it returns a new function and sets this to object PERMANENTLY,
// * STRICT MODE: any reference to global object is undefined

//************************** */ 
// ### ARROW FUNCTIONS: 
//************************** */ 
// * inherit this value from containing function,useful because standalone functions or callback functions reference window/global object with this keyword..(they don't rebind this keyword)

//************************** */ 
// ### OPERATORS:
//************************** */ 
// * typeof: returns type of variable
// * lose equality operator (==), basic defn is that only checks for value, however it does try to convert both types first then performs check
// * strict equality operator(===), basic defn is that checks for value and data type, if rhs is not equal to lhs type it converts rhs then checks for value only, checks objects for reference value

// * If Boolean function is evaluated with non Boolean values, the JS Engine will determine value based on:
//   *FALSY: undefined, null, 0, false, '', NaN
//   *TRUTHY: anything that is not falsy

//************************** */ 
// ### FOR-IN LOOP: used to iterate through an objects' properties or the elements of a collection
//************************** */ 
// * for objects: variable defined in loop is key or propertyName
// * for arrays: variable defined in loop is index
// * returns all members (instance + prototype),
for (let property in object) {
  console.log(`${property}: ${object[property]}`);
}

//************************** */ 
// ### FOR-OF LOOP: ideal way to iterate through arrays or you can use foreach(), ex for (let color of colors) console.log(color);
//************************** */ 
// * variable defined is element in array,
// * can only be used on obects with iterator

//******************************************************************** */ 
// OBJECTS:
//******************************************************************** */ 
const; //keyword ensures the variable will not be reassigned to any other objects
// are DYNAMIC, so you can add/update/delete properties, usedelete keyword
circle.location = {x:1};
delete circle.location;

// 2 ways to access properties:
// dot notation
object.property 
//bracket notation allows us to create dynamic references to property
const propertyName = 'location';
object[propertyName]

// To see if an object has a given property
if ('location' in circle)//checks object + prototype
if (circle.hasOwnProperty('location'))//checks object


//************************* */
//  OBJECT LITERAL SYNTAX: 
//************************* */

// let variableName = { key/value pairs, (properties and their values)};
// properties value can be of any type, or object
// if key and value have same name, you can write 'name: name' as 'name'
const circle = { 
  radius: 1, 
  draw: function() {}
}; 

//************************* */
// * FACTORY FUNCTION, returns object it creates, property values are supplied as arguments, 
//************************* */
function createCircle(radius) { 
  return {
    radius, 
    draw: function() {}
  } 
} 
const circle = createCircle(3);

//************************* */
// * CONSTRUCTOR FUNCTIONS, uses this keyword to add new properties to empty objects, called by new operator and new operator provides empty object
//************************* */
//this keyword binds the members to the object created by new operator, local variables defined by let are accessible only to function(object)
function Circle(radius) { 
  this.radius = radius; 
  this.draw = function() {}
} 
const anotherCircle = new Circle(3);

// We can hide the details by using "private members". Replace "this" with "let". More accurately, these are just local variables but from OOP perspective they are private members 
function Circle(radius) { 
  // Public member 
  this.radius = radius; 
  // Private member                       
  let defaultLocation = {};                      
}     

//************************************* */     
// PRIVATE GETTERS AND SETTERS: (before es6 classes)
// to define and access like properties (object.propertyName)
//************************************* */     
// * FOR FACTORY FUNCTION:
// getters: prefix function inside object with get keyword
// setters: prefix function inside object with set keyword, function has value parameter and at runtime argument will be given by rhs of  
//  assignment operator, use this keyword to set properties,
// use private variables defined before returned object with let keyword

// FOR CONSTRUCTOR FUNCTIONS:
let propertyName = "value";
Object.defineProperty(this, 'propertyName', 
{get: function(){ return propertyName;}, 
set: function(value){propertyName= value;}
});



//************************* */
// ### Every Object has:
//************************* */
// constructor property, references function used to create that object,

// other object methods:
Object.keys(objectName) // returns a string array of className keys, (instance props)
// Object.entries(className), returns a array of key value pairs,
// Object.assign(targetObject, one or more source objects), takes all properties from source object
// and clones the propertys and values to targetObject, EX const circle = Object.Assign({}, sourceCircle);,
// BUT SIMPLER WAY to clone object would be to use spread operator, const circle =
// {...sourceCircle};
// Object.getPrototypeOf(objectName);, gets prototype of object,
// Object.create(shapeBase), returns a new object that inherits from the new shapeBase,
// Object.assign({} or object.Prototype, source object(s)), use this to copy the properties and methods of one object to another or to modify prototype



//************************************************************* */ 
// ### INHERITANCE, Js has prototypical inheritance
//************************************************************* */ 
// * Classical, WHERE WE HAVE CLASSES SO WE HAVE STANDARD INHERITANCE RELATIONSHIP, IE A CIRCLE IS-A SHAPE,

//******************* */
// Prototypical Inheritance, In JS, we only have objects so we have prototypical inheritance. Whenever you hear prototype, think the parent of another object. Every object references the single root object in memory as its prototype. The **proto** property shows parents prototype, so in JS Prototypical inheritance, is when an object performs a method/property call, the JS Engine first looks at that object to see if it has implementation, and if not found then goes up the Prototype chain until found or until it gets to the single root object in memory.
//******************* */

// * The **proto** property is deprecated, but it still viewable for other purposes. Just need to know that EVERY OBJECT CREATED BY SAME CONSTRUCTOR WILL HAVE THE SAME PROTOTYPE.
// * Prototypes should be used to share behavior, not data

// ### Prototype members, 
// *** instead of storing member on each instance created, you can add method to prototype which can still be called from the instance, ex. Circle.prototype.draw = function () {},
// *** don't modify built-in objects you don't own

// ### INTERMEDIATATE FUNCTION INHERITANCE, when you put logic in functions to implement inheritance from new baseObject,
// function extend(Child, Parent){
  // Child.prototype= Object.create(Parent.prototype) OR Child.prototype = new Parent();
  // Child.prototype.constructor = Child
  
  // ### WHEN TO USE INHERITANCE?
  // * Only use on bigger projects, start with simple objects and if many of these objects have same behavior, then combine into generic class
  // * avoid using inheritance hierarchies, if over one level use composition instead!
  // * We use Mixins to achieve composition in JS
  
  //************************** */ 
  // ### STRINGS
  //************************** */ 
  // * TWO TYPES OF STRINGS IN JS,
  //   *String primitive, if you use dot operator it wraps string primitive in object,
  //   *string object, instantiated with new operator
  
  // TEMPLATE LITERALS, indicated by backtick character, helps write cleaner code with strings
  // ${}, allows for substitution of any expression, variable, function within string,
  // whitespaces in backticks are included in string
  
  //************************** */ 
  // ARRAYS
  //************************** */ 
// ADDING ELEMENTS, push(), unshift(), splice
// FINDING PRIMITIVES, indexOf(), lastIndexOf(), includes()
// FINDING REFERENCE TYPES, find(), findIndex()
// CLEARING AN ARRAY, reset reference to empty array, set the length to 0, splice()
// DELETING ELEMENT FROM ARRAY, shift(),
// COMBINING OR SLICING ARRAY, concat(), slice(), SPREAD OPERATOR, (...), when we spread array all of its elements are returned individually
// ITERATING ARRAY, foreach(), for-of loop
// JOINING/SPLITTING ARRAYS, join(), split()
// TESTING ELEMENTS OF ARRAY, every(), some()
// REMOVING ELEMENTS FROM AN ARRAY (FILTERING), filter()
// MAPPING AN ARRAY, map()
// REDUCING AN ARRAY, performing aggregate function with all elements , reduce()

//************************** */ 
// FUNCTIONS, functions are objects!
//************************** */ 
// 2 ways to declare function, function declaration or function expression
// DIFFERENCES,
// expression needs ; at end of {} and declaration does not,
// -function declaration can be called in file before declaration but expression cannot it will throw ReferenceError, this is achieved by HOISTING, the process of moving function declarations to top of file before definition, done by JS Engine

//************************** */ 
// DESTRUCTURING OBJECTS,
//************************** */ 
// Const address = { street : value, city: value, country: value};
// Const street = address.street; const city = address.city; const country = address.country;
// IS SAME AS
// Const { street, city : c, address} = address;

// every function has arguments property that contains all arguments supplied to function call, code will not break if fewer or more arguments are given than defined in parameters,
// REST OPERATOR, (...), used before parameter of function so the varying number of arguments given will be put in array and can be used inside function, cleaner than using arguments property that is in every function,
// rest parameter must be last parameter in function,
// DEFAULT PARAMETERS, can be used by assigning parameter a default value

//************************** */ 
// ### ES6 Classes, the class declaration with class keyword are used to mimic class syntax most people are familiar with, under the hood it is just syntactical sugar for constructor function
//************************** */ 
// class Circle{
  // constructor(param1){this.param1 = param1;}
  // methodName () {logic here}
  // }
  // \*all methods are added to baseCircle prototype, to add to instance you need to define function in constructor, OR USE ARROW FUNCTION defined in class (preferred to reference current object with this keyword and puts method on the object instead of prototype)
  
  //************************** */ 
  // ### RANDOM
  //************************** */ 
  // *class declarations are not hoisted
  // *class body is automatically executed in strict mode, see below for defn
  
  //************************** */ 
  // ### PRIVATE PROPERTIES AND METHODS, can be implemented via:
  //************************** */ 
// * #symbol, look more into it because it is syntactically very easy to use but I want to learn more exactly
// what is going on under the hood and the cost

// ### symbols:
// * sort of private properties because the unique key generated is the name of property and you can set property via bracket notation
// * for private methods use COMPUTED PROPERTY NAMES, brackets with expression with resulting value used as name of method and we use symbol for the expression in brackets
// * not 100% private because built in static Object methods will allow you to access the symbols
// Using symbols to implement private properties and methods
const _size = Symbol();
const _draw = Symbol();

class Square {
    constructor(size) {
        // "Kind of" private property 
        this[_size] = size; 
    }

    // "Kind of" private method 
    [_draw]() {
    }

    // By "kind of" I mean: these properties and methods are essentally
    // part of the object and are accessible from the outside. But accessing
    // them is hard and awkward. 
}

// ### WeakMaps:
// * a new type in es6 to implement private properties and methods, essentially a dictionary where keys are objects and values can be anything, called weak because if object is "weak" or empty reference, garbage collection will occur automatically,
// * Implementation:
//   *you can assign each private property or method to a weakMap ( preferred) or you can put all of them in a single weakMap
//   *place weakmap(s) in module so it cannot be modified directly
// using WeakMaps to implement private properties and methods
const _width = new WeakMap();

class Rectangle {
    constructor(width) {
        _width.set(this, width);
    }

    draw() {
        console.log('Rectangle with width' + _width.get(this));
    }
}

// WeakMaps give us better protection than symbols. There is no way 
// to access private members implemented using WeakMaps from the 
// outside of an object.

// ### ES6 SETTERS/GETTERS,
// -implement with weakmaps
// -get keyword in front of propertyName, return weakMap private variable
// -set keyword in front of propertyName, with value parameter, set weakMap private variable to value


//**************************** */
// ### ES6 INHERITANCE:
//**************************** */
// -use extends keyword, resets prototype and constructor fn() under the hood,
// -use super constructor to call parent constructor and super keyword to access prototype members/methods,if parent has constructor and you wish to put constructor in child then you HAVE to call super constructor first
// Inheritance 
class Triangle extends Shape {
  constructor(color) {
      // To call the base constructor 
      super(color);
  }

  draw() {
      // Call the base method 
      super.draw();

      // Do some other stuff here
  }
}

//**************************** */
// MODULES, why use?
//**************************** */
// to improve maintainability, resusability, and abstraction,
// high level rule is group highly related things together(cohesion),

// Module formats
//  - AMD / Asynchronous Module Definition (Browser)
//  - CommonJS (Node)
//  - UMD / Universal Module Definition (Browser + Node)
//  - ES6 Modules 
// all you really need to know is ES6 Modules for browser and CommonJS which is used with NodeJS

// CommonJS (Used in Node)
// Exporting 
module.exports.Circle = Circle; 
// Importing 
const Circle = require('./circle');

//*********************** */
// ES6 Modules (Used in Browser)
//*********************** */

// Named exports: use export keyword to export one or more objects,
export class Square {}
import {ObjectName[s]} from 'module(path)';
// Default exports: use export default keyword to export main object that is exported from a module,
export default class Square {}
import ObjectName from 'module(path)';

// to import both from a file we use: 
import ObjectName, {OtherObjectName} from â€˜pathâ€™; 
// to understand import line we need to use Webpack or within html file set type attribute to 'module' in script tag

//**************************** */
// ### ES6 TOOLING(for BROWSER SIDE)
//**************************** */
// * transpiler(BABEL), translator+ compiler, converts our JS code into es5 versions so every browser
// can understand, babeljs.io is a website that shows you the conversion of es6+ code to es5,
// * bundler(WEBPACK), combindes all JS files and other files into a bundle, minify code, uglify

//**************************** */
// ### ES6 COMPUTED PROPERTIES, allows us to easily implement dynamic properties based on object passed,
//**************************** */
// ValidateProperty = ({name, value}) => {
  // Const obj = { [name] : value};
  // Joi.validate(obj,â€¦)
  
  //**************************** */
  // ### STRICT MODE:
  //**************************** */
// * throws error if you try to call/modify Window object
// * raises errors on some things that are otherwise silent errors
// * does more but beyond scope of this intro class
